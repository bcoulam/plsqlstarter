<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
 <HEAD>
 <LINK REL="STYLESHEET" TYPE="text/css" HREF="plsqldoc.css">
 <TITLE>Package env</TITLE>
 <META name="object" content="PACKAGE">
 <META name="name" content="env">
 <META name="description" content="%author Bill Coulam (bcoulam@dbartisans.com)">
</HEAD>
<BODY>
<TABLE WIDTH="100%"><TR>
<TD><P ALIGN="LEFT"><STRONG><SMALL></SMALL></STRONG></TD>
<TD><P ALIGN="RIGHT"><STRONG><SMALL><A HREF="index.html">index</A></SMALL></STRONG></TD>
</TR></TABLE>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="DESC_TEXT">
<P CLASS="MAIN_TITLE">Package env</P>
Package of routines that get or set information about the user's session and<br>
&nbsp;execution environment.<br>
&nbsp;<br>
&nbsp;<br>
<pre>
Artisan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comments
============ ========= ========================================================
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1997Dec30 Creation
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008Jan20 Added a few more functions.
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008May19 Added context functions, <A HREF=#caller_meta>caller_meta</A>, <A HREF=#get_routine_nm>get_routine_nm</A>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A HREF=#line_num_here>line_num_here</A>, and fixed private bundle_stack_lines to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work with both 10g and 9i call stacks. Eliminated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redundant get_app_id and get_app_cd functions. Renamed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_current_user to <A HREF=#get_current_schema>get_current_schema</A> (the current_user
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USERENV attribute is deprecated as of 10g). Simplified
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_env_nm. Also added set and clear context routines.
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008Aug18 Added <A HREF=#vld_path_format>vld_path_format</A> to ensure directory paths end in a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash.
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2012Jan24 Added <A HREF=#set_current_schema>set_current_schema</A>. See proc comments for explanation.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Added <A HREF=#tag_longop>tag_longop</A>. See proc comments for explanation.
<i>
&nbsp;&nbsp;&nbsp; __________________________&nbsp; LGPL License&nbsp; ____________________________
&nbsp;&nbsp;&nbsp; Copyright (C) 1997-2008 Bill Coulam

&nbsp;&nbsp;&nbsp; This library is free software; you can redistribute it and/or
&nbsp;&nbsp;&nbsp; modify it under the terms of the GNU Lesser General Public
&nbsp;&nbsp;&nbsp; License as published by the Free Software Foundation; either
&nbsp;&nbsp;&nbsp; version 2.1 of the License, or (at your option) any later version.

&nbsp;&nbsp;&nbsp; This library is distributed in the hope that it will be useful,
&nbsp;&nbsp;&nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp;&nbsp;&nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
&nbsp;&nbsp;&nbsp; Lesser General Public License for more details.

&nbsp;&nbsp;&nbsp; You should have received a copy of the GNU Lesser General Public
&nbsp;&nbsp;&nbsp; License along with this library; if not, write to the Free Software
&nbsp;&nbsp;&nbsp; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA



<BR>
<A NAME="Author"></A>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="LIST_TITLE">
Author
</TD></TR></TABLE>
<TABLE CLASS="MAIN_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Bill Coulam (<A HREF="MAILTO:bcoulam@dbartisans.com">bcoulam@dbartisans.com</A>)
</TD></TR>
</TABLE>
<BR>
<A NAME="Warning"></A>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="LIST_TITLE">
Warning
</TD></TR></TABLE>
<TABLE CLASS="MAIN_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
I worry that wrapping calls to SYS_CONTEXT will bypass Oracle optimizations for SYS_CONTEXT, optimizations that allow SYS_CONTEXT to sail past the usual limitations of calling PL/SQL functions from within SQL statements.
</TD></TR>
</TABLE>
<BR>
</TD></TR></TABLE>
<HR>
<A NAME="Program units"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Program units
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_id">get_client_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Simple wrappers around SYS_CONTEXT functions and environment metadata readily available in the data dictionary.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_ip">get_client_ip</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_host">get_client_host</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_os_user">get_client_os_user</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_program">get_client_program</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_module">get_client_module</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_action">get_client_action</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_session_user">get_session_user</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_current_schema">get_current_schema</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_version">get_db_version</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_name">get_db_name</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_instance_name">get_db_instance_name</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_instance_id">get_db_instance_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_server_host">get_server_host</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_sid">get_sid</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_session_id">get_session_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_os_pid">get_os_pid</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_dir_path">get_dir_path</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_dir_path:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#vld_path_format">vld_path_format</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
vld_path_format:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#who_called_me">who_called_me</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
who_called_me:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#who_am_i">who_am_i</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
who_am_i:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_routine_nm">get_routine_nm</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_routine_nm:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#line_num_here">line_num_here</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
line_num_here:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#caller_meta">caller_meta</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
caller_meta:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tag_session">tag_session</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
tag_session/tag:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tag">tag</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#untag_session">untag_session</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
untag_session/untag:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#untag">untag</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tag_longop">tag_longop</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
tag_longop:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#set_ctx_val">set_ctx_val</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
set_ctx_val:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#set_current_schema">set_current_schema</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
set_current_schema:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#init_client_ctx">init_client_ctx</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
init_client_ctx :
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#reset_client_ctx">reset_client_ctx</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
reset_client_ctx:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#clear_ctx_val">clear_ctx_val</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
clear_ctx_val:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#clear_ctx">clear_ctx</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
clear_ctx:
</TD></TR>
</TABLE>
<BR>
<A NAME="Types"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Types
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_info">trace_info</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tar_trace_info">tar_trace_info</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#t_longop">t_longop</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<A NAME="Variables"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Variables
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#g_trace_stack">g_trace_stack</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#g_call_stack">g_call_stack</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<A NAME="Constants"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Constants
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#FMWK_CTX">FMWK_CTX</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_info"></A>
<P CLASS="TYPE_TITLE">
trace_info
</P>
<PRE CLASS="DECL_TEXT">
TYPE trace_info IS RECORD (
 module typ.t_module,
 action typ.t_action,
 client_info typ.t_client_id
);
</PRE>
<HR>
<A NAME="tar_trace_info"></A>
<P CLASS="TYPE_TITLE">
tar_trace_info
</P>
<PRE CLASS="DECL_TEXT">
TYPE tar_trace_info IS TABLE OF <A HREF=#trace_info>trace_info</A> INDEX BY PLS_INTEGER;
</PRE>
<HR>
<A NAME="t_longop"></A>
<P CLASS="TYPE_TITLE">
t_longop
</P>
<PRE CLASS="DECL_TEXT">
TYPE t_longop IS RECORD (
  total_work     NUMBER DEFAULT 0                                                                                                  
 ,work_done      NUMBER DEFAULT 0                              
 ,units_of_measure VARCHAR2(32 BYTE) DEFAULT NULL                                                                                 
 ,op_nm          VARCHAR2(64 BYTE) DEFAULT 'Unknown'                                                      
 ,work_target    VARCHAR2(32 BYTE) DEFAULT 'Unknown'                                                                  
 ,work_target_id PLS_INTEGER DEFAULT 0                                                          
 ,row_key        PLS_INTEGER DEFAULT dbms_application_info.set_session_longops_nohint                                                              
 ,sl_num         PLS_INTEGER                                                                                         
);
</PRE>
<HR>
<A NAME="FMWK_CTX"></A>
<P CLASS="TYPE_TITLE">
FMWK_CTX
</P>
<PRE CLASS="DECL_TEXT">
FMWK_CTX CONSTANT VARCHAR2(20) := LOWER('APP1_ctx');
</PRE>
<HR>
<A NAME="g_trace_stack"></A>
<P CLASS="TYPE_TITLE">
g_trace_stack
</P>
<PRE CLASS="DECL_TEXT">
g_trace_stack tar_trace_info;
</PRE>
<HR>
<A NAME="g_call_stack"></A>
<P CLASS="TYPE_TITLE">
g_call_stack
</P>
<PRE CLASS="DECL_TEXT">
g_call_stack  typ.t_maxcol;
</PRE>
<HR>
<A NAME="get_client_id"></A>
<P CLASS="TYPE_TITLE">
get_client_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_id RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
Simple wrappers around SYS_CONTEXT functions and environment metadata readily available in the data dictionary.<br>

<BR>
</P>
<HR>
<A NAME="get_client_ip"></A>
<P CLASS="TYPE_TITLE">
get_client_ip
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_ip RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_host"></A>
<P CLASS="TYPE_TITLE">
get_client_host
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_host RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_os_user"></A>
<P CLASS="TYPE_TITLE">
get_client_os_user
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_os_user RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_program"></A>
<P CLASS="TYPE_TITLE">
get_client_program
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_program RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_module"></A>
<P CLASS="TYPE_TITLE">
get_client_module
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_module RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_action"></A>
<P CLASS="TYPE_TITLE">
get_client_action
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_action RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_session_user"></A>
<P CLASS="TYPE_TITLE">
get_session_user
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_session_user RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_current_schema"></A>
<P CLASS="TYPE_TITLE">
get_current_schema
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_current_schema RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_db_version"></A>
<P CLASS="TYPE_TITLE">
get_db_version
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_version RETURN NUMBER

</PRE>
<HR>
<A NAME="get_db_name"></A>
<P CLASS="TYPE_TITLE">
get_db_name
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_name RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_db_instance_name"></A>
<P CLASS="TYPE_TITLE">
get_db_instance_name
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_instance_name RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_db_instance_id"></A>
<P CLASS="TYPE_TITLE">
get_db_instance_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_instance_id RETURN NUMBER

</PRE>
<HR>
<A NAME="get_server_host"></A>
<P CLASS="TYPE_TITLE">
get_server_host
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_server_host RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_sid"></A>
<P CLASS="TYPE_TITLE">
get_sid
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_sid RETURN INTEGER

</PRE>
<HR>
<A NAME="get_session_id"></A>
<P CLASS="TYPE_TITLE">
get_session_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_session_id RETURN INTEGER

</PRE>
<HR>
<A NAME="get_os_pid"></A>
<P CLASS="TYPE_TITLE">
get_os_pid
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_os_pid RETURN INTEGER

</PRE>
<HR>
<A NAME="get_dir_path"></A>
<P CLASS="TYPE_TITLE">
get_dir_path
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_dir_path(i_dir_nm IN VARCHAR2) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
get_dir_path:<br>
&nbsp;Queries all_directories to find the directory path behind a given 9i-style<br>
&nbsp;directory name.<br>

<BR>
</P>
<HR>
<A NAME="vld_path_format"></A>
<P CLASS="TYPE_TITLE">
vld_path_format
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION vld_path_format(i_path IN VARCHAR2) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
vld_path_format:<br>
&nbsp;Ensures that there is a directory slash character after a given path. If the<br>
&nbsp;given path does not end in a slash, one will be appended. This is useful for<br>
&nbsp;routines that piece together full paths, where the content and validity of the<br>
&nbsp;path piece is uncertain. When Oracle directory objects are created, they may or<br>
&nbsp;may not have the trailing slash.<br>

<BR>
</P>
<HR>
<A NAME="who_called_me"></A>
<P CLASS="TYPE_TITLE">
who_called_me
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION who_called_me(i_stack_level IN PLS_INTEGER DEFAULT 2) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
who_called_me:<br>
&nbsp;By default, returns the name of the package or standalone one level further up<br>
&nbsp;in the call stack, which represents the caller of the routine that called this<br>
&nbsp;function. When called indirectly by another layer in the framework, the stack<br>
&nbsp;level needs to be increased from the default to find out who the real<br>
&nbsp;caller's caller is.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_stack_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The depth in the stack to look for caller info.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Credits"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Credits
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Inspiration for this routine name and the code behind it came from Tom Kyte.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="who_am_i"></A>
<P CLASS="TYPE_TITLE">
who_am_i
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION who_am_i(i_stack_level IN PLS_INTEGER DEFAULT 1) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
who_am_i:<br>
&nbsp;By default, returns the name of the package or standalone that called this<br>
&nbsp;function. When called indirectly by another layer in the framework, the stack<br>
&nbsp;level needs to be increased from the default to find out who the real caller is.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_stack_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The depth in the stack to look for caller info.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Credits"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Credits
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Inspiration for this routine name and the code behind it came from Tom Kyte.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_routine_nm"></A>
<P CLASS="TYPE_TITLE">
get_routine_nm
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_routine_nm
(
   i_pkg_nm   IN VARCHAR2,
   i_line_num IN INTEGER
) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
get_routine_nm:<br>
&nbsp;Given a package name and line number, returns the name of the routine within<br>
&nbsp;which that line number currently falls. The ability of a subroutine to<br>
&nbsp;introspect and find its own name is a basic ability of most programming and<br>
&nbsp;scripting languages, but not PL/SQL. Hence the reason for this routine.<br>
&nbsp;<br>
&nbsp;By parsing the call stack (available in most versions of Oracle) or using the<br>
&nbsp;new $$PLSQL_UNIT and $$PLSQL_LINE directives, we can get at the package and<br>
&nbsp;line. Either of these methods can produce the inputs required for this<br>
&nbsp;function.<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;The accuracy of this function depends on the code following one simple<br>
&nbsp;convention, which is:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Always immediately follow the PROCEDURE and FUNCTION declaration with its name.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Example: CREATE OR REPLACE PACKAGE test AS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCEDURE first_proc( &lt;-- fine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION get_val... &lt;-- fine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCEDURE -- inline comment about this proc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; second_proc; &lt;-- will not work with env.get_routine_nm()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END test;<br>
&nbsp;<br>
&nbsp;If you allow the routine name to go on a line separate from its declaration,<br>
&nbsp;this function will not work and return NULL.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_pkg_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the package in which to find the routine name by line number.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_line_num&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The line number which the caller is claiming as the location of the introspection request.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="General Comments"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
General Comments
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
This was originally a private function, meant to be used exclusively by the <A HREF=#caller_meta>caller_meta</A>() routine. However, since it could be useful in other contexts, it was exposed. The logging library indirectly uses this routine heavily so that the callers of the logging routines do not have to pass in their location, name or containing package explicitly. If you only desire to use this function for logging purposes, use the LOGS package instead, and inherit this ability by default.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Design Notes"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Design Notes
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Two designs were tested, one where the metadata for each package was stored in a table and maintained by trigger (nature of DDL in AFTER ALTER triggers requires that the trigger submit jobs to update the table), and one where the metadata is gathered at the time of request. Running a test of 1700 random line numbers within a schema with 140 packages, the persistent table version returned accurate routine names in 1.3 seconds for 1700 total calls, whereas the dynamic version got the same results in 2.8 seconds. Since get_routine_nm wouldn't be called that heavily within most production environments, I decided to eliminate the overhead of the extra moving parts and stick with the dynamic version instead. That is why this routine just uses one complex SQL statement, instead of a static table or materialized result set.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Caveat"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Caveat
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
If you still need to call this function, know that it is only useful for _packaged_ routines.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="line_num_here"></A>
<P CLASS="TYPE_TITLE">
line_num_here
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION line_num_here(i_stack_level IN PLS_INTEGER DEFAULT 1) RETURN INTEGER

</PRE>
<P CLASS="DESC_TEXT">
line_num_here:<br>
&nbsp;Looks in the call stack to the given depth and returns the line number from<br>
&nbsp;which line_num_here was called.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
<code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When you want to record a line number other than the line at which the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGS routine is called. This is analagous to the old method of setting<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &quot;marker&quot; variable before each chunk of code, which would get recorded<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with any error/info logging for context and later research:<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l_line := $$PLSQL_LINE; -- implemenation for &gt;= 9.2.0.6<br>&nbsp;&nbsp;&nbsp; l_line := env.line_num_here; -- implementation for &lt;= 9.2.0.5<br>&nbsp;&nbsp;&nbsp; mypkg.do_something_useful(i_date, l_length);<br>&nbsp;&nbsp;&nbsp; logs.dbg(i_msg=&gt;'Did something useful', i_line_num =&gt; l_line);<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When you are OK with recording the line number as the line from which the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call to logs was made, use this simpler method instead:<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 9.2.0.6<br>&nbsp;&nbsp;&nbsp; logs.info('Awaiting pipe message', 'DBMS_PIPE Listener', $$PLSQL_LINE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 9.2.0.5<br>&nbsp;&nbsp;&nbsp; logs.info('Awaiting pipe message', 'DBMS_PIPE Listener', env.line_num_here);<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remember that the LOGS routines transparently determine routine name and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line number for you. So unless you want to use a custom name, like<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBMS_PIPE Listener in the examples above, don't worry about line number,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for example:<br>&nbsp;&nbsp;&nbsp; logs.info('Awaiting pipe message');<br> <br> <br>

</TD></TR>
</TABLE>
<BR>
<A NAME="General Comments"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
General Comments
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
This is not necessary from 9.2.0.6 onwards where you can use $$PLSQL_LINE to get the same result. However, in 9.2.0.6, you have to set the _plsql_conditional_compilation flag to TRUE in order to use it.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="caller_meta"></A>
<P CLASS="TYPE_TITLE">
caller_meta
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE caller_meta
(
   o_owner       OUT typ.t_maxobjnm,
   o_caller_type OUT user_objects.object_type%TYPE,
   o_unit_nm     OUT user_objects.object_name%TYPE,
   o_routine_nm  OUT app_log.routine_nm%TYPE,
   o_line_num    OUT app_log.line_num%TYPE,
   i_stack_level IN PLS_INTEGER DEFAULT 1
)

</PRE>
<P CLASS="DESC_TEXT">
caller_meta:<br>
&nbsp;Returns all the metadata about the caller at the given level in the call stack.<br>
&nbsp;It is anticipated that the only consumer of this proc will be the LOGS library<br>
&nbsp;routines (msg, err, warn, info and dbg).<br>
&nbsp;The caller data includes the fully qualified routine name, which is the name of<br>
&nbsp;the type body, function, proc, trigger or package.routine_name. If the caller<br>
&nbsp;is an anonymous block, the name will be ANONYMOUSBLOCK.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_owner&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The schema name of the owner of the caller DB object.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_caller_type&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The PL/SQL unit type, including ANONYMOUS BLOCK<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_unit_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The PL/SQL unit name. For packages, this is limited to the package name.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_routine_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
For packages, this is the the full name of the calling object. Will be package.routine_nm for packaged routines.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_line_num&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The line number in the call stack from which the call was made.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_stack_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
How deep to look in the stack for for the callers metadata. Defaults to 1 level deep (immediate caller). The framework components must use stack level 2 to get one layer above where they sit in the call stack.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="tag_session"></A>
<P CLASS="TYPE_TITLE">
tag_session
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE tag_session
(
   i_module IN typ.t_module DEFAULT NULL,
   i_action IN typ.t_action DEFAULT NULL,
   i_info   IN typ.t_client_info DEFAULT NULL
)

</PRE>
<P CLASS="DESC_TEXT">
tag_session/tag:<br>
&nbsp;Sets MODULE, ACTION and CLIENT_INFO to the provided values. These values are<br>
&nbsp;visible in V$SESSION and other performance views. Use this routine frequently<br>
&nbsp;to instrument your code and DDL/DML upgrade scripts.<br>
&nbsp;<br>
&nbsp;Since this places custom tags in v$session, it gives DBAs more visibility into<br>
&nbsp;the systems they manage, and a better ability to measure, tune, find and track.<br>
&nbsp;<br>
&nbsp;Remember to clear these values out using <A HREF=#untag_session>env.untag_session</A>, or else the values<br>
&nbsp;will remain for the duration of the session, possibly causing those<br>
&nbsp;investigating issues to pursue the wrong path.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
<code><br>&nbsp;&nbsp;&nbsp; exec env.tag_session('CR53885','Re-create Constraint','CONTACTS_UK');<br> <br>&nbsp;&nbsp;&nbsp; ALTER TABLE contacts<br>&nbsp;&nbsp;&nbsp; DROP CONSTRAINT contacts_uk<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; ALTER TABLE contacts<br>&nbsp;&nbsp;&nbsp; ADD CONSTRAINT contacts_uk<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; exec ddl_utils.analyze_index('CONTACTS_UK');<br>&nbsp;&nbsp;&nbsp; exec env.untag_session;<br> </code>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_module&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The governing &quot;module&quot;, usually the change request/ticket#, the business process, or PL/SQL package name. If not given, the name of the calling package (if any) will be determined transparently. Truncated by Oracle to 48 characters.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The current &quot;action&quot;, usually something like &quot;Create Index&quot;, &quot;Move Table&quot;, etc. The packaged procedure/function name is also a frequently-used value. If not given, the name of the calling routine will be determined transparently. Truncated by Oracle to 32 characters.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_info&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The detail of the current step, usually the name of the table, index or constraint being created/altered/queried. Could be the ID of the business item being processed, or a running count indicating how much work is done and how much there is left to go. If not supplied, the line number from which tag_session was called in the calling routine will be used instead. Truncated by Oracle to 64 characters.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="tag"></A>
<P CLASS="TYPE_TITLE">
tag
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE tag
(
   i_module IN typ.t_module DEFAULT NULL,
   i_action IN typ.t_action DEFAULT NULL,
   i_info   IN typ.t_client_info DEFAULT NULL
)

</PRE>
<HR>
<A NAME="untag_session"></A>
<P CLASS="TYPE_TITLE">
untag_session
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE untag_session(i_restore_prior_tag IN BOOLEAN DEFAULT TRUE)

</PRE>
<P CLASS="DESC_TEXT">
untag_session/untag:<br>
&nbsp;Sets MODULE, ACTION and CLIENT_INFO in v$session to NULL.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_restore_prior_tag&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
If TRUE (the default), will attempt to read the global variable, gv_trace_info to see if prior trace data is stored there. If so, it will use these values instead of NULL. This allows modules called by other modules to restore the module/action/info as it was prior to the current module call and use of tag/tag_session.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="General Comments"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
General Comments
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Make sure to call this after calling <A HREF=#tag_session>tag_session</A>(). Otherwise the info fed to <A HREF=#tag_session>tag_session</A> will remain attached to your session, fooling administrators into thinking your session is still working on the module indicated in v$session, when in fact your session has ended or moved on to other actions.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="untag"></A>
<P CLASS="TYPE_TITLE">
untag
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE untag(i_restore_prior_tag IN BOOLEAN DEFAULT TRUE)

</PRE>
<HR>
<A NAME="tag_longop"></A>
<P CLASS="TYPE_TITLE">
tag_longop
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE tag_longop(io_longop IN OUT <A HREF=#t_longop>env.t_longop</A>)

</PRE>
<P CLASS="DESC_TEXT">
tag_longop:<br>
&nbsp;Call once before beginning long call/operation, which seeds a row in v$session_longops.<br>
&nbsp;Then call periodically during the operation to update the work_done attribute to communicate,<br>
&nbsp;in real-time, the progress of the operation. If the operation does multiple things and<br>
&nbsp;changes the object it is processing, also update the total_work, op_nm and work_target<br>
&nbsp;to indicate the change in direction and new set of work.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_longop&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Record of attributes used by underlying call to dbms_application_info<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="General Comments"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
General Comments
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
All of the fields in this record should be set before the first call to tag_longops (except optional work_target_id, and row_key/sl_num which the system sets for you).<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="set_ctx_val"></A>
<P CLASS="TYPE_TITLE">
set_ctx_val
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE set_ctx_val
(
   i_attr_nm  IN VARCHAR2,
   i_attr_val IN VARCHAR2,
   i_ctx_nm   IN VARCHAR2 DEFAULT <A HREF=#FMWK_CTX>fmwk_ctx</A>
)

</PRE>
<P CLASS="DESC_TEXT">
set_ctx_val:<br>
&nbsp;You associate this routine with an application-specific context during<br>
&nbsp;application context creation. Then call this routine when setting the values<br>
&nbsp;of attributes within the context. If the application context (the Oracle docs<br>
&nbsp;seem to use &quot;application context&quot; and &quot;context namespace&quot; interchangeably) is<br>
&nbsp;not named, the default namespace for the Core framework will be used.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
<code><br>&nbsp;&nbsp;&nbsp;&nbsp; CREATE CONTEXT my_ctx USING env.set_ctx_val;<br>&nbsp;&nbsp;&nbsp;&nbsp; exec env.set_ctx_val('remote_login_attempts','5','my_ctx');<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; followed by calls to PL/SQL stored objects that include controls on<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remote login attempts by querying the in-memory context value using<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYS_CONTEXT('my_ctx','remote_login_attempts')<br> </code>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_attr_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the attribute whose value will be set in the context for the current session.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_attr_val&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Value of the attribute within the application context.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_ctx_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application context. Defaults to framework's context.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="General Comments"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
General Comments
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The Core framework uses this routine to maintain the value of the in-memory debug flag parameter.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="set_current_schema"></A>
<P CLASS="TYPE_TITLE">
set_current_schema
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE set_current_schema(i_schema_nm IN VARCHAR2)

</PRE>
<P CLASS="DESC_TEXT">
set_current_schema:<br>
&nbsp;Takes an Oracle account/schema name, and places it in the session's client<br>
&nbsp;context memory structure for later use when read by <A HREF=#get_current_schema>get_current_schema</A>.<br>
&nbsp;<br>
&nbsp;For most systems where the application resides in one schema, and calls upon<br>
&nbsp;services in the framework in the same or another schema, this routine is not<br>
&nbsp;necessary as the framework will determine the current schema being used for<br>
&nbsp;execution dynamically. I call this a two layer use of the framework.<br>
&nbsp;<br>
&nbsp;However, for systems where schema A calls upon a definer-rights stored<br>
&nbsp;routine in schema B, or a view or trigger in schema B (neither of which can<br>
&nbsp;use invoker-rights), which make use of the framework, any attempt to get the<br>
&nbsp;application's current schema will return schema B, not schema A as it should.<br>
&nbsp;I call this a three or N-layer use of the framework, which it really wasn't<br>
&nbsp;designed for.<br>
&nbsp;<br>
&nbsp;So this routine was added to allow a session to statically place its object-<br>
&nbsp;owning or DB access account name (see app_env.owner_account and access_account<br>
&nbsp;columns and how they help map applications and databases to named environments)<br>
&nbsp;into memory where it can be retrieved by the framework calls within schema B.<br>
&nbsp;This call would ideally be done within an AFTER LOGON trigger in the schema to<br>
&nbsp;which the application server connects.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_schema_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Valid Oracle account name. Will be uppercased before being stored. So ensure it matches a valid account value in APP_ENV.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="init_client_ctx"></A>
<P CLASS="TYPE_TITLE">
init_client_ctx
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE init_client_ctx
(
   i_client_id      IN VARCHAR2,
   i_client_ip      IN VARCHAR2 DEFAULT NULL,
   i_client_host    IN VARCHAR2 DEFAULT NULL,
   i_client_os_user IN VARCHAR2 DEFAULT NULL
)

</PRE>
<P CLASS="DESC_TEXT">
init_client_ctx :<br>
&nbsp;Takes a user identifier from the caller (usually the presentation layer that<br>
&nbsp;served up the login screen to the user), and places it in the session's<br>
&nbsp;client_identifier USERENV application context area. This can be used by<br>
&nbsp;standard Oracle auditing, or FGA, or custom trigger-based auditing, to report<br>
&nbsp;who (within the application's users sharing the connection pool) did what, and<br>
&nbsp;when.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_id&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
User's login ID, be it employee ID, name, LDAP DN, whatever can identify the end user. If this is an automated process, assign it a name and use that name consistently here and when logging.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_ip&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional IP address. If using connection pools and shared schemas, this will default to the address of the application server, unless you pass it the user's IP address explicitly.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_host&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional name of the machine or terminal from the which the user is logging in to use the application. Again, for applications using connection pools, this will default to the application server's host name unless the front end passes the client machine name explicitly.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_os_user&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional operating system login ID. This is more useful when the user is connected directly to the database, or for automated processes. But if the front end layer has this information, they should feel free to pass it in.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="reset_client_ctx"></A>
<P CLASS="TYPE_TITLE">
reset_client_ctx
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE reset_client_ctx

</PRE>
<P CLASS="DESC_TEXT">
reset_client_ctx:<br>
&nbsp;Must be called by the front-end layer controlling transactions and access to the<br>
&nbsp;connection pool. This empties the client context and resets package state, so that<br>
&nbsp;the next user who inherits these in-memory objects doesn't also inherit the same<br>
&nbsp;values.<br>

<BR>
</P>
<A NAME="Warning"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Warning
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
This routine re-initializes several things, including the session state that held the dbms_output buffer. So make sure you are pulling relevant text out of the buffer (if you are using dbms_output.get_line(s)) before you call reset_client_ctx.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="clear_ctx_val"></A>
<P CLASS="TYPE_TITLE">
clear_ctx_val
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE clear_ctx_val
(
   i_attr_nm IN VARCHAR2,
   i_ctx_nm  IN VARCHAR2 DEFAULT <A HREF=#FMWK_CTX>fmwk_ctx</A>
)

</PRE>
<P CLASS="DESC_TEXT">
clear_ctx_val:<br>
&nbsp;This routine will set the value of the attribute within the given namespace to<br>
&nbsp;NULL.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this routine when the value of an in-memory application context attribute is no longer needed. This prevents the value from being inherited by other connections or sessions (I lose track of which is which).<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_attr_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the attribute whose value will be set to NULL.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_ctx_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application context. Defaults to framework's context.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="clear_ctx"></A>
<P CLASS="TYPE_TITLE">
clear_ctx
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE clear_ctx(i_ctx_nm IN VARCHAR2 DEFAULT <A HREF=#FMWK_CTX>fmwk_ctx</A>)

</PRE>
<P CLASS="DESC_TEXT">
clear_ctx:<br>
&nbsp;This routine will set the value of all attributes within the given namespace to<br>
&nbsp;NULL.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this routine when a session is over and the connection is about to be returned to the pool. This prevents the values in the namespace from being inherited by other connections or sessions (I lose track of which is which).<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_ctx_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application context. Defaults to framework's context.<br>

</TD></TR>
</TABLE>
<BR>
<P>&nbsp;</P>
<P>&nbsp;</P>
</BODY>
</HTML>
