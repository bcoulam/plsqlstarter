<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
 <HEAD>
 <LINK REL="STYLESHEET" TYPE="text/css" HREF="plsqldoc.css">
 <TITLE>Package excp</TITLE>
 <META name="object" content="PACKAGE">
 <META name="name" content="excp">
 <META name="description" content="%author Bill Coulam (bcoulam@dbartisans.com)">
</HEAD>
<BODY>
<TABLE WIDTH="100%"><TR>
<TD><P ALIGN="LEFT"><STRONG><SMALL></SMALL></STRONG></TD>
<TD><P ALIGN="RIGHT"><STRONG><SMALL><A HREF="index.html">index</A></SMALL></STRONG></TD>
</TR></TABLE>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="DESC_TEXT">
<P CLASS="MAIN_TITLE">Package excp</P>
Package of public exceptions and some common routines (<A HREF=#assert>assert</A> and <A HREF=#throw>throw</A>) to<br>
&nbsp;assist in error-handling code.<br>
&nbsp;<br>
<pre>
Artisan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comments
============ ========= ========================================================
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1997Dec30 Creation

<i>
&nbsp;&nbsp;&nbsp; __________________________&nbsp; LGPL License&nbsp; ____________________________
&nbsp;&nbsp;&nbsp; Copyright (C) 1997-2008 Bill Coulam

&nbsp;&nbsp;&nbsp; This library is free software; you can redistribute it and/or
&nbsp;&nbsp;&nbsp; modify it under the terms of the GNU Lesser General Public
&nbsp;&nbsp;&nbsp; License as published by the Free Software Foundation; either
&nbsp;&nbsp;&nbsp; version 2.1 of the License, or (at your option) any later version.

&nbsp;&nbsp;&nbsp; This library is distributed in the hope that it will be useful,
&nbsp;&nbsp;&nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp;&nbsp;&nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
&nbsp;&nbsp;&nbsp; Lesser General Public License for more details.

&nbsp;&nbsp;&nbsp; You should have received a copy of the GNU Lesser General Public
&nbsp;&nbsp;&nbsp; License along with this library; if not, write to the Free Software
&nbsp;&nbsp;&nbsp; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA



<BR>
<A NAME="Author"></A>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="LIST_TITLE">
Author
</TD></TR></TABLE>
<TABLE CLASS="MAIN_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Bill Coulam (<A HREF="MAILTO:bcoulam@dbartisans.com">bcoulam@dbartisans.com</A>)
</TD></TR>
</TABLE>
<BR>
</TD></TR></TABLE>
<HR>
<A NAME="Program units"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Program units
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#assert">assert</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
assert:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#throw">throw</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
throw:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#throw2">throw</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<A NAME="Exceptions"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Exceptions
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_parent_integrity_constraint">gx_parent_integrity_constraint</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
PUBLIC CONSTANTS, VARIABLES, EXCEPTIONS, ETC.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_unique_integrity_constraint">gx_unique_integrity_constraint</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_child_integrity_constraint">gx_child_integrity_constraint</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_check_integrity_constraint">gx_check_integrity_constraint</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_date_format_mismatch">gx_date_format_mismatch</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_invalid_day_in_month">gx_invalid_day_in_month</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_date_mask_short">gx_date_mask_short</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_invalid_month">gx_invalid_month</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_invalid_week">gx_invalid_week</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_invalid_day">gx_invalid_day</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_row_locked">gx_row_locked</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#gx_pkg_state_old">gx_pkg_state_old</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="gx_parent_integrity_constraint"></A>
<P CLASS="TYPE_TITLE">
gx_parent_integrity_constraint
</P>
<PRE CLASS="DECL_TEXT">
gx_parent_integrity_constraint EXCEPTION;
</PRE>
<P CLASS="DESC_TEXT">
PUBLIC CONSTANTS, VARIABLES, EXCEPTIONS, ETC.<br>

<BR>
</P>
<HR>
<A NAME="gx_unique_integrity_constraint"></A>
<P CLASS="TYPE_TITLE">
gx_unique_integrity_constraint
</P>
<PRE CLASS="DECL_TEXT">
gx_unique_integrity_constraint EXCEPTION;
</PRE>
<HR>
<A NAME="gx_child_integrity_constraint"></A>
<P CLASS="TYPE_TITLE">
gx_child_integrity_constraint
</P>
<PRE CLASS="DECL_TEXT">
gx_child_integrity_constraint EXCEPTION;
</PRE>
<HR>
<A NAME="gx_check_integrity_constraint"></A>
<P CLASS="TYPE_TITLE">
gx_check_integrity_constraint
</P>
<PRE CLASS="DECL_TEXT">
gx_check_integrity_constraint EXCEPTION;
</PRE>
<HR>
<A NAME="gx_date_format_mismatch"></A>
<P CLASS="TYPE_TITLE">
gx_date_format_mismatch
</P>
<PRE CLASS="DECL_TEXT">
gx_date_format_mismatch EXCEPTION;
</PRE>
<HR>
<A NAME="gx_invalid_day_in_month"></A>
<P CLASS="TYPE_TITLE">
gx_invalid_day_in_month
</P>
<PRE CLASS="DECL_TEXT">
gx_invalid_day_in_month EXCEPTION;
</PRE>
<HR>
<A NAME="gx_date_mask_short"></A>
<P CLASS="TYPE_TITLE">
gx_date_mask_short
</P>
<PRE CLASS="DECL_TEXT">
gx_date_mask_short EXCEPTION;
</PRE>
<HR>
<A NAME="gx_invalid_month"></A>
<P CLASS="TYPE_TITLE">
gx_invalid_month
</P>
<PRE CLASS="DECL_TEXT">
gx_invalid_month EXCEPTION;
</PRE>
<HR>
<A NAME="gx_invalid_week"></A>
<P CLASS="TYPE_TITLE">
gx_invalid_week
</P>
<PRE CLASS="DECL_TEXT">
gx_invalid_week EXCEPTION;
</PRE>
<HR>
<A NAME="gx_invalid_day"></A>
<P CLASS="TYPE_TITLE">
gx_invalid_day
</P>
<PRE CLASS="DECL_TEXT">
gx_invalid_day EXCEPTION;
</PRE>
<HR>
<A NAME="gx_row_locked"></A>
<P CLASS="TYPE_TITLE">
gx_row_locked
</P>
<PRE CLASS="DECL_TEXT">
gx_row_locked EXCEPTION;
</PRE>
<HR>
<A NAME="gx_pkg_state_old"></A>
<P CLASS="TYPE_TITLE">
gx_pkg_state_old
</P>
<PRE CLASS="DECL_TEXT">
gx_pkg_state_old EXCEPTION;
</PRE>
<HR>
<A NAME="assert"></A>
<P CLASS="TYPE_TITLE">
assert
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE assert
(
   i_expr       IN BOOLEAN,
   i_msg        IN VARCHAR2,
   i_raise_excp IN BOOLEAN DEFAULT TRUE,
   i_excp_nm    IN VARCHAR2 DEFAULT NULL,
   i_routine_nm IN app_log.routine_nm%TYPE DEFAULT NULL,
   i_line_num   IN app_log.line_num%TYPE DEFAULT NULL
)

</PRE>
<P CLASS="DESC_TEXT">
assert:<br>
&nbsp;Assertions allow you to verify assumptions before proceeding in a program.<br>
&nbsp;Pass an expression that has a boolean result. Assert will check it for true or<br>
&nbsp;false, and raise an exception if the assertion checked is false. If you wish<br>
&nbsp;the program to continue, you will need to pass FALSE in for the third parameter.<br>
&nbsp;In this case, when i_raise_excp is FALSE, the assertion will be sent to the<br>
&nbsp;output buffer (to screen, which will not be seen by Java clients or batch<br>
&nbsp;programs) and to the APP_LOG table.<br>
&nbsp;<br>
&nbsp;In most cases, you will not need to fill the i_excp_nm parameter, it will default<br>
&nbsp;to VALUE_ERROR. However, if you have another bound or pre-defined exception, you<br>
&nbsp;may pass that in by name as well.<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;Numbers:<br>
&nbsp;&nbsp; excp.assert(i_run_id &gt; 0, 'Run ID must be a positive integer.');<br>
&nbsp;&nbsp; excp.assert(LENGTH(l_str) &lt; 4000,'Message is too long');<br>
&nbsp;&nbsp; Note: Messages will be printed to the screen and (in case it is a batch<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; program) to the logging table.<br>
&nbsp;Dates:<br>
&nbsp;&nbsp; excp.assert(i_start_dtm &gt;= dt.get_sysdt,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Time travel violation. Start date must be in the future');<br>
&nbsp;Strings:<br>
&nbsp;&nbsp; excp.assert(l_code IN ('U','X','Z'), 'Valid codes are U, X and Z.');<br>
&nbsp;Boolean:<br>
&nbsp;&nbsp; excp.assert(l_continue_flg = TRUE, 'Continue Flag is false.');<br>
&nbsp;NULL conditions:<br>
&nbsp;&nbsp; excp.assert(l_stmt IS NOT NULL, 'Provided statement can''t be empty.');<br>
&nbsp;&nbsp; excp.assert(l_var IS NULL, 'Variable l_var already had a value.');<br>
&nbsp;<br>
&nbsp;Optional named exception handling:<br>
&nbsp;&nbsp; excp.assert(l_state_busy, NULL, TRUE, 'excp.gx_row_locked');<br>
&nbsp;<br>
&nbsp;Optional log and continue:<br>
&nbsp;&nbsp; excp.assert(i_expr =&gt; l_var IS NULL,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i_msg =&gt; 'Variable l_var already had a value.'<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i_raise_excp =&gt; FALSE);<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Anything that can be turned into a Boolean expression can serve as the first parameter to assert().<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_expr&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Boolean expression, e.g. &quot;1000 = i_num_recs&quot;, &quot;i_rec_type IS NOT NULL&quot;, &quot;l_control_num != l_counter&quot;, etc.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_msg&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The message that will be fed to the error stack (if re-raising) or to the screen and APP_LOG table (if continuing).<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_raise_excp&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Whether to raise an exception or allow processing to continue.<br>

<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
TRUE&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Default. Raises named exception (see i_excp_nm), or VALUE_ERROR if no name given.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
FALSE&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Pass FALSE if you wish to allow the program to continue after logging the assertion failure (not recommended).<br>

</TD></TR>
</TABLE>
<BR>
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_excp_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Can be an Oracle pre-defined exception, or a user-defined exception. If user-defined, the exception must be publicly visible (declared in a package specification).<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_routine_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The name of the procedure, function, trigger, object or package.routine from which the assertion was tested. If not given, this will be determined for you. This parameter is only needed if i_raise_excp is FALSE.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_line_num&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The line number where the caller wishes to indicate the assertion failure occurred. If not given, this will be determined for you and will point to the line where excp.assert was called. This parameter is only needed if i_raise_excp is FALSE.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="throw"></A>
<P CLASS="TYPE_TITLE">
throw
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE throw
(
   i_msg_id IN app_msg.msg_id%TYPE DEFAULT SQLCODE,
   i_msg    IN VARCHAR2 DEFAULT SQLERRM
)

</PRE>
<P CLASS="DESC_TEXT">
throw:<br>
&nbsp;Throw is called mainly by the LOGS package for most exception handling, replacing<br>
&nbsp;hard-coded and conflicting IDs frequently used with RAISE_APPLICATION_ERROR.<br>
&nbsp;<br>
&nbsp;Replacing direct calls to RAISE_APPLICATION_ERROR helps reduce hard-code,<br>
&nbsp;enforcing consistent exception handling, and coordinates use and re-use of IDs<br>
&nbsp;and messages (found in Oracle's base error library and in the APP_MSG table).<br>
&nbsp;<br>
&nbsp;In general, you will always call one of the LOGS routines and let it know<br>
&nbsp;whether to re-raise the trapped exception. If you have a need to bypass logging<br>
&nbsp;and immediately raise an error, then you can call throw().<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;Exception raising where an application exception is being replaced by throw:<br>
&nbsp;&nbsp; throw(-20050,'Cannot read APP_PARM. Check permissions.');<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Simple user-defined exception raising: throw; -- raises the last SQLCODE with its SQLERRM throw(9980); -- User defined error ID. Should have error text defined in APP_MSG. Literals are discouraged. Use logs.err or logs.msg instead. throw(msgs.get_msg_id('Heinous Error')); -- Message will be looked up in app_msg OR throw('Heinous Error','Detected awful error. Processing halted.'); -- Message in app_msg overwritten by this one<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_msg_id&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Positive or negative error number, either from APP_MSG or from list of Oracle error numbers (allowed user-defined range, or Oracle pre-defined).<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_msg_cd&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Named message, found in APP_MSG table. You can also invent one on the spot, like &quot;My Awesome Message&quot;, or use the default Ad-Hoc Message code reference by msgs.DEFAULT_MSG_CD.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_msg&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Custom message to be raised along with the user-defined exception ID.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Note"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Note
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The message text is optional. If you provide text, it will be used. If you don't provide text, the message text will be looked up in APP_MSG.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Caveats"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Caveats
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Throw, by itself, does no logging. We want to log most errors we come across. Therefore, you should not be using throw directly, if at all. Usually if it is an error that warrants attention, but not immediate, you will call logs.msg or logs.warn. If it is or could be disastrous, you will call logs.msg('Storage Error',cnst.ERROR,'Filesystem full.',TRUE); or logs.err('Nasty error.'); both of which log and call <A HREF=#throw2>excp.throw</A> to re-raise the exception.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Design Story"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Design Story
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
I chose &quot;throw&quot; because &quot;raise&quot; is a reserved word in PL/SQL. Our Oracle tools uppercase &quot;raise&quot; when typed. This meant that you'd have to go back and change it back to lowercase to meet format standards. Not fun. So I went with &quot;throw&quot; which matches Java terminology, the other half of most application tech stacks.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="throw2"></A>
<P CLASS="TYPE_TITLE">
throw
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE throw
(
   i_msg_cd IN app_msg.msg_cd%TYPE,
   i_msg    IN VARCHAR2 DEFAULT NULL
)

</PRE>
<P>&nbsp;</P>
<P>&nbsp;</P>
</BODY>
</HTML>
