<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
 <HEAD>
 <LINK REL="STYLESHEET" TYPE="text/css" HREF="plsqldoc.css">
 <TITLE>Package env</TITLE>
 <META name="object" content="PACKAGE">
 <META name="name" content="env">
 <META name="description" content="%author Bill Coulam (bcoulam@dbartisans.com)">
</HEAD>
<BODY>
<TABLE WIDTH="100%"><TR>
<TD><P ALIGN="LEFT"><STRONG><SMALL></SMALL></STRONG></TD>
<TD><P ALIGN="RIGHT"><STRONG><SMALL><A HREF="index.html">index</A></SMALL></STRONG></TD>
</TR></TABLE>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="DESC_TEXT">
<P CLASS="MAIN_TITLE">Package env</P>
Package of routines that get or set information about the user's session and<br>
&nbsp;execution environment.<br>
&nbsp;<br>
%warn<br>
&nbsp;I worry that wrapping calls to SYS_CONTEXT will bypass Oracle optimizations<br>
&nbsp;for SYS_CONTEXT, optimizations that allow SYS_CONTEXT to sail past the usual<br>
&nbsp;limitations of calling PL/SQL functions from within SQL statements. I did a<br>
&nbsp;brief test on a table with 500K rows. The cost reported by the CBO was greater,<br>
&nbsp;but the response time was about the same. If you discover that calling these<br>
&nbsp;wrapped versions of SYS_CONTEXT calls is slower, by all means, use the direct<br>
&nbsp;calls to SYS_CONTEXT instead.<br>
&nbsp;<br>
<pre>
Artisan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Date&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Comments
============ ========= ========================================================
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1997Dec30 Creation
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008Jan20 Added a few more functions.
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008May19 Added context functions, <A HREF=#caller_meta>caller_meta</A>, <A HREF=#get_routine_nm>get_routine_nm</A>,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A HREF=#line_num_here>line_num_here</A>, and fixed private bundle_stack_lines to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; work with both 10g and 9i call stacks. Eliminated
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; redundant <A HREF=#get_app_id>get_app_id</A> and <A HREF=#get_app_cd>get_app_cd</A> functions. Renamed
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get_current_user to <A HREF=#get_current_schema>get_current_schema</A> (the current_user
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USERENV attribute is deprecated as of 10g). Simplified
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <A HREF=#get_env_nm>get_env_nm</A>. Also added set and clear context routines.
bcoulam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2008Aug18 Added <A HREF=#vld_path_format>vld_path_format</A> to ensure directory paths end in a
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slash.

<i>
&nbsp;&nbsp;&nbsp; __________________________&nbsp; LGPL License&nbsp; ____________________________
&nbsp;&nbsp;&nbsp; Copyright (C) 1997-2008 Bill Coulam

&nbsp;&nbsp;&nbsp; This library is free software; you can redistribute it and/or
&nbsp;&nbsp;&nbsp; modify it under the terms of the GNU Lesser General Public
&nbsp;&nbsp;&nbsp; License as published by the Free Software Foundation; either
&nbsp;&nbsp;&nbsp; version 2.1 of the License, or (at your option) any later version.

&nbsp;&nbsp;&nbsp; This library is distributed in the hope that it will be useful,
&nbsp;&nbsp;&nbsp; but WITHOUT ANY WARRANTY; without even the implied warranty of
&nbsp;&nbsp;&nbsp; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
&nbsp;&nbsp;&nbsp; Lesser General Public License for more details.

&nbsp;&nbsp;&nbsp; You should have received a copy of the GNU Lesser General Public
&nbsp;&nbsp;&nbsp; License along with this library; if not, write to the Free Software
&nbsp;&nbsp;&nbsp; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA



<BR>
<A NAME="Author"></A>
<TABLE CLASS="MAIN_TABLE"><TR><TD CLASS="LIST_TITLE">
Author
</TD></TR></TABLE>
<TABLE CLASS="MAIN_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Bill Coulam (<A HREF="MAILTO:bcoulam@dbartisans.com">bcoulam@dbartisans.com</A>)
</TD></TR>
</TABLE>
<BR>
</TD></TR></TABLE>
<HR>
<A NAME="Program units"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Program units
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_id">get_client_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Simple wrappers around SYS_CONTEXT functions and environment metadata readily available in the data dictionary.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_ip">get_client_ip</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_host">get_client_host</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_os_user">get_client_os_user</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_program">get_client_program</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
derived from [g]v$session.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_module">get_client_module</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_client_action">get_client_action</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_session_user">get_session_user</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_current_schema">get_current_schema</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
could be different from session user if current_schema was altered
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_version">get_db_version</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
stand-in for older systems missing DBMS_DB_VERSION
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_name">get_db_name</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_instance_name">get_db_instance_name</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
if RAC db, returns SID/SERVICE NAME otherwise
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_instance_id">get_db_instance_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
if RAC db, returns 1 otherwise
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_server_host">get_server_host</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
name of db host
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_sid">get_sid</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Note: get_sid and <A HREF=#get_session_id>get_session_id</A> do the same thing; get_sid is just easier to remember.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_session_id">get_session_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
db session ID ([g]v$session.sid)
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_os_pid">get_os_pid</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
db host operating system process ID
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_schema_email_address">get_schema_email_address</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
FUNCTION get_global_context_memory RETURN VARCHAR2;
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_db_id">get_db_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_db_id:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_app_id">get_app_id</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_app_id:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_app_cd">get_app_cd</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_app_cd:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_env_nm">get_env_nm</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_env_nm:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_dir_path">get_dir_path</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_dir_path:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#vld_path_format">vld_path_format</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
vld_path_format:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#who_called_me">who_called_me</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
who_called_me:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#who_am_i">who_am_i</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
who_am_i:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#get_routine_nm">get_routine_nm</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
get_routine_nm:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#line_num_here">line_num_here</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
line_num_here:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#caller_meta">caller_meta</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
caller_meta:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tag_session">tag_session</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
tag_session/tag:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tag">tag</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
New version that doesn't require caller to pass anything in.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#untag_session">untag_session</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
untag_session/untag:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#untag">untag</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
New version that doesn't require caller to pass anything in.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#set_ctx_val">set_ctx_val</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
set_ctx_val:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#set_app_cd">set_app_cd</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
set_app_cd:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#init_client_ctx">init_client_ctx</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
init_client_ctx :
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#reset_client_ctx">reset_client_ctx</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
reset_client_ctx:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#clear_ctx_val">clear_ctx_val</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
clear_ctx_val:
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#clear_ctx">clear_ctx</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
clear_ctx:
</TD></TR>
</TABLE>
<BR>
<A NAME="Types"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Types
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#trace_info">trace_info</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
PUBLIC TYPES
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#tar_trace_info">tar_trace_info</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
trace stack datatype
</TD></TR>
</TABLE>
<BR>
<A NAME="Variables"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Variables
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#g_trace_stack">g_trace_stack</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Global in-memory structure to keep track of the trace info used by the tag/untag routines.
</TD></TR>
</TABLE>
<BR>
<A NAME="Constants"></A>
<TABLE CLASS="SUB_TABLE"><TR><TD CLASS="SUB_TITLE">
Constants
</TD></TR></TABLE>
<TABLE CLASS="SUB_TABLE">
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#DOMAIN">DOMAIN</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
PUBLIC CONSTANTS, VARIABLES, EXCEPTIONS, ETC.
</TD></TR>
<TR><TD VALIGN="TOP" CLASS="TYPE_ITEM">
<A HREF="#APP_CORE_CTX">APP_CORE_CTX</A>&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="trace_info"></A>
<P CLASS="TYPE_TITLE">
trace_info
</P>
<PRE CLASS="DECL_TEXT">
TYPE trace_info IS RECORD (
 module v$session.module%TYPE,
 action v$session.action%TYPE,
 client_info v$session.client_info%TYPE
);
</PRE>
<P CLASS="DESC_TEXT">
PUBLIC TYPES<br>
&nbsp;<br>
basic trace structure type<br>

<BR>
</P>
<HR>
<A NAME="tar_trace_info"></A>
<P CLASS="TYPE_TITLE">
tar_trace_info
</P>
<PRE CLASS="DECL_TEXT">
TYPE tar_trace_info IS TABLE OF <A HREF=#trace_info>trace_info</A> INDEX BY PLS_INTEGER;
</PRE>
<P CLASS="DESC_TEXT">
trace stack datatype<br>

<BR>
</P>
<HR>
<A NAME="DOMAIN"></A>
<P CLASS="TYPE_TITLE">
DOMAIN
</P>
<PRE CLASS="DECL_TEXT">
DOMAIN CONSTANT VARCHAR2(30) := 'ldschurch.org';
</PRE>
<P CLASS="DESC_TEXT">
PUBLIC CONSTANTS, VARIABLES, EXCEPTIONS, ETC.<br>

<BR>
</P>
<HR>
<A NAME="APP_CORE_CTX"></A>
<P CLASS="TYPE_TITLE">
APP_CORE_CTX
</P>
<PRE CLASS="DECL_TEXT">
APP_CORE_CTX CONSTANT VARCHAR2(20) := 'app_core_ctx';
</PRE>
<HR>
<A NAME="g_trace_stack"></A>
<P CLASS="TYPE_TITLE">
g_trace_stack
</P>
<PRE CLASS="DECL_TEXT">
g_trace_stack tar_trace_info;
</PRE>
<P CLASS="DESC_TEXT">
Global in-memory structure to keep track of the trace info used by the tag/untag routines. This is used to reset the trace info back to its previous values when the calling module finishes and returns control to the calling routine.<br>

<BR>
</P>
<HR>
<A NAME="get_client_id"></A>
<P CLASS="TYPE_TITLE">
get_client_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_id RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
Simple wrappers around SYS_CONTEXT functions and environment metadata readily available in the data dictionary.<br>

<BR>
</P>
<HR>
<A NAME="get_client_ip"></A>
<P CLASS="TYPE_TITLE">
get_client_ip
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_ip RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_host"></A>
<P CLASS="TYPE_TITLE">
get_client_host
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_host RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_os_user"></A>
<P CLASS="TYPE_TITLE">
get_client_os_user
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_os_user RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_program"></A>
<P CLASS="TYPE_TITLE">
get_client_program
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_program RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
derived from [g]v$session. Not in USERENV<br>

<BR>
</P>
<HR>
<A NAME="get_client_module"></A>
<P CLASS="TYPE_TITLE">
get_client_module
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_module RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_client_action"></A>
<P CLASS="TYPE_TITLE">
get_client_action
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_client_action RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_session_user"></A>
<P CLASS="TYPE_TITLE">
get_session_user
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_session_user RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_current_schema"></A>
<P CLASS="TYPE_TITLE">
get_current_schema
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_current_schema RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
could be different from session user if current_schema was altered<br>

<BR>
</P>
<HR>
<A NAME="get_db_version"></A>
<P CLASS="TYPE_TITLE">
get_db_version
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_version RETURN NUMBER

</PRE>
<P CLASS="DESC_TEXT">
stand-in for older systems missing DBMS_DB_VERSION<br>

<BR>
</P>
<HR>
<A NAME="get_db_name"></A>
<P CLASS="TYPE_TITLE">
get_db_name
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_name RETURN VARCHAR2

</PRE>
<HR>
<A NAME="get_db_instance_name"></A>
<P CLASS="TYPE_TITLE">
get_db_instance_name
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_instance_name RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
if RAC db, returns SID/SERVICE NAME otherwise<br>

<BR>
</P>
<HR>
<A NAME="get_db_instance_id"></A>
<P CLASS="TYPE_TITLE">
get_db_instance_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_instance_id RETURN NUMBER

</PRE>
<P CLASS="DESC_TEXT">
if RAC db, returns 1 otherwise<br>

<BR>
</P>
<HR>
<A NAME="get_server_host"></A>
<P CLASS="TYPE_TITLE">
get_server_host
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_server_host RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
name of db host<br>

<BR>
</P>
<HR>
<A NAME="get_sid"></A>
<P CLASS="TYPE_TITLE">
get_sid
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_sid RETURN INTEGER

</PRE>
<P CLASS="DESC_TEXT">
Note: get_sid and <A HREF=#get_session_id>get_session_id</A> do the same thing; get_sid is just easier to remember.<br>

<BR>
</P>
<HR>
<A NAME="get_session_id"></A>
<P CLASS="TYPE_TITLE">
get_session_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_session_id RETURN INTEGER

</PRE>
<P CLASS="DESC_TEXT">
db session ID ([g]v$session.sid)<br>

<BR>
</P>
<HR>
<A NAME="get_os_pid"></A>
<P CLASS="TYPE_TITLE">
get_os_pid
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_os_pid RETURN INTEGER

</PRE>
<P CLASS="DESC_TEXT">
db host operating system process ID<br>

<BR>
</P>
<HR>
<A NAME="get_schema_email_address"></A>
<P CLASS="TYPE_TITLE">
get_schema_email_address
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_schema_email_address RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
FUNCTION get_global_context_memory RETURN VARCHAR2;<br>

<BR>
</P>
<HR>
<A NAME="get_db_id"></A>
<P CLASS="TYPE_TITLE">
get_db_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_db_id RETURN INTEGER

</PRE>
<P CLASS="DESC_TEXT">
get_db_id:<br>
&nbsp;Uses the db_name returned by sys_context to query APP_DB and return a numeric<br>
&nbsp;ID for the current database.<br>

<BR>
</P>
<HR>
<A NAME="get_app_id"></A>
<P CLASS="TYPE_TITLE">
get_app_id
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_app_id(i_app_cd IN app.app_cd%TYPE DEFAULT NULL) RETURN NUMBER

</PRE>
<P CLASS="DESC_TEXT">
get_app_id:<br>
&nbsp;If the app_cd is given, returns the app_id from the APP table.<br>
&nbsp;<br>
&nbsp;If the app_cd is missing, will return app_id from the in-memory record private<br>
&nbsp;to ENV. If this has not been filled yet, it will attempt to determine the<br>
&nbsp;application transparently using values from the USERENV context and the DB Name,<br>
&nbsp;matching up to data in APP, APP_DB and APP_ENV. In environments where multiple<br>
&nbsp;applications share the same owning schema, they must set the app_cd into the<br>
&nbsp;default <A HREF=#APP_CORE_CTX>env.APP_CORE_CTX</A> context at the time of connection. They can do this by<br>
&nbsp;ensuring they call <A HREF=#init_client_ctx>env.init_client_ctx</A> and passing in the app_cd at the start of<br>
&nbsp;their session. Or they can do this by calling <A HREF=#set_ctx_val>env.set_ctx_val</A> directly.<br>
&nbsp;<br>
&nbsp;If the app_cd cannot be determined, an error is raised.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_app_cd&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application, as stored in table APP.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_app_cd"></A>
<P CLASS="TYPE_TITLE">
get_app_cd
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_app_cd(i_app_id IN app.app_id%TYPE DEFAULT NULL) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
get_app_cd:<br>
&nbsp;If the app_id is given, returns the app code from the APP table.<br>
&nbsp;<br>
&nbsp;If the app_id is missing, will transparently attempt to get the app_id using<br>
&nbsp;<A HREF=#get_app_id>get_app_id</A>().<br>
&nbsp;<br>
&nbsp;If the app_cd cannot be determined, will return NULL.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_app_id&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
ID of the application, as stored in table APP.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_env_nm"></A>
<P CLASS="TYPE_TITLE">
get_env_nm
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_env_nm(i_app_cd IN app.app_cd%TYPE DEFAULT NULL) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
get_env_nm:<br>
&nbsp;Queries APP_ENV to determine the name of the current environment, given the<br>
&nbsp;current schema, database name and application.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_app_cd&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional application code.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_dir_path"></A>
<P CLASS="TYPE_TITLE">
get_dir_path
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_dir_path(i_dir_nm IN VARCHAR2) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
get_dir_path:<br>
&nbsp;Queries all_directories to find the directory path behind a given 9i-style<br>
&nbsp;directory name.<br>

<BR>
</P>
<HR>
<A NAME="vld_path_format"></A>
<P CLASS="TYPE_TITLE">
vld_path_format
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION vld_path_format(i_path IN VARCHAR2) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
vld_path_format:<br>
&nbsp;Ensures that there is a directory slash character after a given path. If the<br>
&nbsp;given path does not end in a slash, one will be appended. This is useful for<br>
&nbsp;routines that piece together full paths, where the content and validity of the<br>
&nbsp;path piece is uncertain. When Oracle directory objects are created, they may or<br>
&nbsp;may not have the trailing slash.<br>

<BR>
</P>
<HR>
<A NAME="who_called_me"></A>
<P CLASS="TYPE_TITLE">
who_called_me
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION who_called_me(i_stack_level IN PLS_INTEGER DEFAULT 2) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
who_called_me:<br>
&nbsp;By default, returns the name of the package or standalone one level further up<br>
&nbsp;in the call stack, which represents the caller of the routine that called this<br>
&nbsp;function. When called indirectly by another layer in the framework, the stack<br>
&nbsp;level needs to be increased from the default to find out who the real<br>
&nbsp;caller's caller is.<br>
&nbsp;<br>
%credit<br>
&nbsp;Inspiration for this routine name and the code behind it came from Tom Kyte.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_stack_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The depth in the stack to look for caller info.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="who_am_i"></A>
<P CLASS="TYPE_TITLE">
who_am_i
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION who_am_i(i_stack_level IN PLS_INTEGER DEFAULT 1) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
who_am_i:<br>
&nbsp;By default, returns the name of the package or standalone that called this<br>
&nbsp;function. When called indirectly by another layer in the framework, the stack<br>
&nbsp;level needs to be increased from the default to find out who the real caller is.<br>
&nbsp;<br>
%credit<br>
&nbsp;Inspiration for this routine name and the code behind it came from Tom Kyte.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_stack_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The depth in the stack to look for caller info.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="get_routine_nm"></A>
<P CLASS="TYPE_TITLE">
get_routine_nm
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION get_routine_nm
(
   i_pkg_nm   IN VARCHAR2,
   i_line_num IN INTEGER
) RETURN VARCHAR2

</PRE>
<P CLASS="DESC_TEXT">
get_routine_nm:<br>
&nbsp;Given a package name and line number, returns the name of the routine within<br>
&nbsp;which that line number currently falls. The ability of a subroutine to<br>
&nbsp;introspect and find its own name is a basic ability of most programming and<br>
&nbsp;scripting languages, but not PL/SQL. Hence the reason for this routine.<br>
&nbsp;<br>
&nbsp;By parsing the call stack (available in most versions of Oracle) or using the<br>
&nbsp;new $$PLSQL_UNIT and $$PLSQL_LINE directives, we can get at the package and<br>
&nbsp;line. Either of these methods can produce the inputs required for this<br>
&nbsp;function.<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;The accuracy of this function depends on the code following one simple<br>
&nbsp;convention, which is:<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Always immediately follow the PROCEDURE and FUNCTION declaration with its name.<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp; Example: CREATE OR REPLACE PACKAGE test AS<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCEDURE first_proc( &lt;-- fine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; );<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FUNCTION get_val... &lt;-- fine<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PROCEDURE -- inline comment about this proc<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; second_proc; &lt;-- will not work with env.get_routine_nm()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END test;<br>
&nbsp;<br>
&nbsp;If you allow the routine name to go on a line separate from its declaration,<br>
&nbsp;this function will not work and return NULL.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_pkg_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the package in which to find the routine name by line number.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_line_num&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The line number which the caller is claiming as the location of the introspection request.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Note"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Note
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
This was originally a private function, meant to be used exclusively by the <A HREF=#caller_meta>caller_meta</A>() routine. However, since it could be useful in other contexts, it was exposed. The logging library indirectly uses this routine heavily so that the callers of the logging routines do not have to pass in their location, name or containing package explicitly. If you only desire to use this function for logging purposes, use the LOGS package instead, and inherit this ability by default.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Caveats"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Caveats
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
If you still need to call this function, know that it is only useful for _packaged_ routines.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Design Story"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Design Story
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Two designs were tested, one where the metadata for each package was stored in a table and maintained by trigger (nature of DDL in AFTER ALTER triggers requires that the trigger submit jobs to update the table), and one where the metadata is gathered at the time of request. Running a test of 1700 random line numbers within a schema with 140 packages, the persistent table version returned accurate routine names in 1.3 seconds for 1700 total calls, whereas the dynamic version got the same results in 2.8 seconds. Since get_routine_nm wouldn't be called that heavily within most production environments, I decided to eliminate the overhead of the extra moving parts and stick with the dynamic version instead. That is why this routine just uses one complex SQL statement, instead of a static table or materialized result set.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="line_num_here"></A>
<P CLASS="TYPE_TITLE">
line_num_here
</P>
<PRE CLASS="DECL_TEXT">
FUNCTION line_num_here(i_stack_level IN PLS_INTEGER DEFAULT 1) RETURN INTEGER

</PRE>
<P CLASS="DESC_TEXT">
line_num_here:<br>
&nbsp;Looks in the call stack to the given depth and returns the line number from<br>
&nbsp;which line_num_here was called.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
<code><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When you want to record a line number other than the line at which the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOGS routine is called. This is analagous to the old method of setting<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a &quot;marker&quot; variable before each chunk of code, which would get recorded<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; with any error/info logging for context and later research:<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l_line := $$PLSQL_LINE; -- implemenation for &gt;= 9.2.0.6<br>&nbsp;&nbsp;&nbsp; l_line := env.line_num_here; -- implementation for &lt;= 9.2.0.5<br>&nbsp;&nbsp;&nbsp; mypkg.do_something_useful(i_date, l_length);<br>&nbsp;&nbsp;&nbsp; logs.dbg(i_msg=&gt;'Did something useful', i_line_num =&gt; l_line);<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; When you are OK with recording the line number as the line from which the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call to logs was made, use this simpler method instead:<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;= 9.2.0.6<br>&nbsp;&nbsp;&nbsp; logs.info('Awaiting pipe message', 'DBMS_PIPE Listener', $$PLSQL_LINE);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;= 9.2.0.5<br>&nbsp;&nbsp;&nbsp; logs.info('Awaiting pipe message', 'DBMS_PIPE Listener', env.line_num_here);<br> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Remember that the LOGS routines transparently determine routine name and<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line number for you. So unless you want to use a custom name, like<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBMS_PIPE Listener in the examples above, don't worry about line number,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for example:<br>&nbsp;&nbsp;&nbsp; logs.info('Awaiting pipe message');<br> <br> <br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Note"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Note
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
This is not necessary from 9.2.0.6 onwards where you can use $$PLSQL_LINE to get the same result. However, in 9.2.0.6, you have to set the _plsql_conditional_compilation flag to TRUE in order to use it.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="caller_meta"></A>
<P CLASS="TYPE_TITLE">
caller_meta
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE caller_meta
(
   o_owner       OUT typ.t_maxobjnm,
   o_caller_type OUT user_objects.object_type%TYPE,
   o_unit_nm     OUT user_objects.object_name%TYPE,
   o_routine_nm  OUT app_log.routine_nm%TYPE,
   o_line_num    OUT app_log.line_num%TYPE,
   i_stack_level IN PLS_INTEGER DEFAULT 1
)

</PRE>
<P CLASS="DESC_TEXT">
caller_meta:<br>
&nbsp;Returns all the metadata about the caller at the given level in the call stack.<br>
&nbsp;It is anticipated that the only consumer of this proc will be the LOGS library<br>
&nbsp;routines (msg, err, warn, info and dbg).<br>
&nbsp;The caller data includes the fully qualified routine name, which is the name of<br>
&nbsp;the type body, function, proc, trigger or package.routine_name. If the caller<br>
&nbsp;is an anonymous block, the name will be ANONYMOUSBLOCK.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_owner&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The schema name of the owner of the caller DB object.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_caller_type&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The PL/SQL unit type, including ANONYMOUS BLOCK<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_unit_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The PL/SQL unit name. For packages, this is limited to the package name.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_routine_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
For packages, this is the the full name of the calling object. Will be package.routine_nm for packaged routines.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
o_line_num&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The line number in the call stack from which the call was made.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_stack_level&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
How deep to look in the stack for for the callers metadata. Defaults to 1 level deep (immediate caller). The framework components must use stack level 2 to get one layer above where they sit in the call stack.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="tag_session"></A>
<P CLASS="TYPE_TITLE">
tag_session
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE tag_session
(
   i_module IN VARCHAR2,
   i_action IN VARCHAR2,
   i_info   IN VARCHAR2
)

</PRE>
<P CLASS="DESC_TEXT">
tag_session/tag:<br>
&nbsp;Sets MODULE, ACTION and CLIENT_INFO in v$session to the provided values. Use<br>
&nbsp;this routine frequently to instrument your code and DDL/DML upgrade scripts.<br>
&nbsp;<br>
&nbsp;Since this places custom tags in v$session, it gives DBAs more visibility into<br>
&nbsp;the systems they manage, and a better ability to measure, tune, find and track.<br>
&nbsp;<br>
&nbsp;Remember to clear these values out using <A HREF=#untag_session>env.untag_session</A>, or else the values<br>
&nbsp;will remain for the duration of the session, possibly causing those<br>
&nbsp;investigating issues to pursue the wrong path.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
<code><br>&nbsp;&nbsp;&nbsp; exec env.tag_session('CR53885','Re-create Constraint','CONTACTS_UK');<br> <br>&nbsp;&nbsp;&nbsp; ALTER TABLE contacts<br>&nbsp;&nbsp;&nbsp; DROP CONSTRAINT contacts_uk<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; ALTER TABLE contacts<br>&nbsp;&nbsp;&nbsp; ADD CONSTRAINT contacts_uk<br>&nbsp;&nbsp;&nbsp; ...<br>&nbsp;&nbsp;&nbsp; exec ddl_utils.analyze_index('CONTACTS_UK');<br>&nbsp;&nbsp;&nbsp; exec env.untag_session;<br> </code>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_module&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The governing &quot;module&quot;, usually the change request/ticket#. The PL/SQL package name is also a frequently-used value. If not given, the name of the calling package (if any) will be determined transparently. Limited to 48 characters.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_action&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The current &quot;action&quot;, usually something like &quot;Create Index&quot;, &quot;Move Table&quot;, etc. The packaged procedure/function name is also a frequently-used value. If not given, the name of the calling routine will be determined transparently. Limited to 32 characters.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_info&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The detail of the current step, usually the name of the table, index or constraint being created/altered/queried. If not supplied, the line number from which tag_session was called in the calling routine will be used instead. Limited to 64 characters.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="tag"></A>
<P CLASS="TYPE_TITLE">
tag
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE tag
(
   i_module IN VARCHAR2 DEFAULT NULL,
   i_action IN VARCHAR2 DEFAULT NULL,
   i_info   IN VARCHAR2 DEFAULT NULL
)

</PRE>
<P CLASS="DESC_TEXT">
New version that doesn't require caller to pass anything in. Also shorter name.<br>

<BR>
</P>
<HR>
<A NAME="untag_session"></A>
<P CLASS="TYPE_TITLE">
untag_session
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE untag_session(i_restore_prior_tag IN BOOLEAN DEFAULT TRUE)

</PRE>
<P CLASS="DESC_TEXT">
untag_session/untag:<br>
&nbsp;Sets MODULE, ACTION and CLIENT_INFO in v$session to NULL.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_restore_prior_tag&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
If TRUE (the default), will attempt to read the global variable, gv_trace_info to see if prior trace data is stored there. If so, it will use these values instead of NULL. This allows modules called by other modules to restore the module/action/info as it was prior to the current module call and use of tag/tag_session.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Note"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Note
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Make sure to call this after calling <A HREF=#tag_session>tag_session</A>(). Otherwise the info fed to <A HREF=#tag_session>tag_session</A> will remain attached to your session, fooling administrators into thinking your session is still working on the module indicated in v$session, when in fact your session has ended or moved on to other actions.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="untag"></A>
<P CLASS="TYPE_TITLE">
untag
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE untag(i_restore_prior_tag IN BOOLEAN DEFAULT TRUE)

</PRE>
<P CLASS="DESC_TEXT">
New version that doesn't require caller to pass anything in. Also shorter name.<br>

<BR>
</P>
<HR>
<A NAME="set_ctx_val"></A>
<P CLASS="TYPE_TITLE">
set_ctx_val
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE set_ctx_val
(
   i_attr_nm  IN VARCHAR2,
   i_attr_val IN VARCHAR2,
   i_ctx_nm   IN VARCHAR2 DEFAULT <A HREF=#APP_CORE_CTX>app_core_ctx</A>
)

</PRE>
<P CLASS="DESC_TEXT">
set_ctx_val:<br>
&nbsp;You associate this routine with an application-specific context during<br>
&nbsp;application context creation. Then call this routine when setting the values<br>
&nbsp;of attributes within the context. If the application context (the Oracle docs<br>
&nbsp;seem to use &quot;application context&quot; and context namespace interchangeably) is<br>
&nbsp;not named, the default namespace for the Core framework will be used.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
<code><br>&nbsp;&nbsp;&nbsp;&nbsp; CREATE CONTEXT my_ctx USING env.set_ctx_val;<br>&nbsp;&nbsp;&nbsp;&nbsp; exec env.set_ctx_val('remote_login_attempts','5','my_ctx');<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; followed by calls to PL/SQL stored objects that include controls on<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; remote login attempts by querying the in-memory context value using<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SYS_CONTEXT('my_ctx','remote_login_attempts')<br> </code>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_attr_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the attribute whose value will be set in the context for the current session.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_attr_val&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Value of the attribute within the application context.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_ctx_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application context. Defaults to framework's context.<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Note"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Note
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
The Core framework uses this routine to maintain the value of the in-memory debug flag parameter.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="set_app_cd"></A>
<P CLASS="TYPE_TITLE">
set_app_cd
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE set_app_cd(i_app_cd IN app.app_cd%TYPE)

</PRE>
<P CLASS="DESC_TEXT">
set_app_cd:<br>
&nbsp;Takes a short code for a given application (found listed in the APP table),<br>
&nbsp;and sets it as the value for the &quot;app_cd&quot; attribute in the Core application<br>
&nbsp;context.<br>
&nbsp;<br>
&nbsp;This routine is meant to be called by jobs, or DBAs manually running routines<br>
&nbsp;by anonymous block. In these situations the client or user ID might not be<br>
&nbsp;readily known or relevant, and only the app_cd is needed to activate the<br>
&nbsp;framework's dynamic views. This could be called at the top of the &quot;what&quot; block<br>
&nbsp;in the job. A great place for the call is within the initialization section of<br>
&nbsp;a package. If you are designing a system that resides in its own dedicated<br>
&nbsp;schema, this routine need only be called once from an AFTER LOGON trigger. But<br>
&nbsp;if you have the unfortunate luck of working in a schema that serves multiple<br>
&nbsp;applications, this routine will need to be called explicitly by the packages<br>
&nbsp;and jobs dedicated to a given system.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_app_cd&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Application code as found in APP.APP_CD<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="init_client_ctx"></A>
<P CLASS="TYPE_TITLE">
init_client_ctx
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE init_client_ctx
(
   i_client_id      IN VARCHAR2,
   i_client_ip      IN VARCHAR2 DEFAULT NULL,
   i_client_host    IN VARCHAR2 DEFAULT NULL,
   i_client_os_user IN VARCHAR2 DEFAULT NULL,
   i_app_cd         IN VARCHAR2 DEFAULT NULL
)

</PRE>
<P CLASS="DESC_TEXT">
init_client_ctx :<br>
&nbsp;Takes a user identifier from the caller (usually the presentation layer that<br>
&nbsp;served up the login screen to the user), and places it in the session's<br>
&nbsp;client_identifier USERENV application context area. This can be used by<br>
&nbsp;standard Oracle auditing, or FGA, or custom trigger-based auditing, to report<br>
&nbsp;who (within the application's users sharing the connection pool) did what, and<br>
&nbsp;when.<br>

<BR>
</P>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_id&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
User's login ID, be it employee ID, name, LDAP DN, whatever can identify the end user. If this is an automated process, assign it a name and use that name consistently here and when logging.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_ip&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional IP address. If using connection pools and shared schemas, this will default to the address of the application server, unless you pass it the user's IP address explicitly.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_host&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional name of the machine or terminal from the which the user is logging in to use the application. Again, for applications using connection pools, this will default to the application server's host name unless the front end passes the client machine name explicitly.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_client_os_user&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Optional operating system login ID. This is more useful when the user is connected directly to the database, or for automated processes. But if the front end layer has this information, they should feel free to pass it in.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_app_cd&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
An application code from APP.APP_CD. Mandatory if this is an environment where multiple applications share a single schema.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="reset_client_ctx"></A>
<P CLASS="TYPE_TITLE">
reset_client_ctx
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE reset_client_ctx

</PRE>
<P CLASS="DESC_TEXT">
reset_client_ctx:<br>
&nbsp;Must be called by the front-end layer controlling transactions and access to the<br>
&nbsp;connection pool. This empties the client context and resets package state, so that<br>
&nbsp;the next user who inherits these in-memory objects doesn't also inherit the same<br>
&nbsp;values.<br>
&nbsp;<br>
%warn<br>
&nbsp;This routine re-initializes several things, including the session state that<br>
&nbsp;held the dbms_output buffer. So make sure you are pulling relevant text out of the<br>
&nbsp;buffer (if you are using dbms_output.get_line(s)) before you call reset_client_ctx.<br>

<BR>
</P>
<HR>
<A NAME="clear_ctx_val"></A>
<P CLASS="TYPE_TITLE">
clear_ctx_val
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE clear_ctx_val
(
   i_attr_nm IN VARCHAR2,
   i_ctx_nm  IN VARCHAR2 DEFAULT <A HREF=#APP_CORE_CTX>app_core_ctx</A>
)

</PRE>
<P CLASS="DESC_TEXT">
clear_ctx_val:<br>
&nbsp;This routine will set the value of the attribute within the given namespace to<br>
&nbsp;NULL.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this routine when the value of an in-memory application context attribute is no longer needed. This prevents the value from being inherited by other connections or sessions (I lose track of which is which).<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_attr_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the attribute whose value will be set to NULL.<br>

</TD></TR>
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_ctx_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application context. Defaults to framework's context.<br>

</TD></TR>
</TABLE>
<BR>
<HR>
<A NAME="clear_ctx"></A>
<P CLASS="TYPE_TITLE">
clear_ctx
</P>
<PRE CLASS="DECL_TEXT">
PROCEDURE clear_ctx(i_ctx_nm IN VARCHAR2 DEFAULT <A HREF=#APP_CORE_CTX>app_core_ctx</A>)

</PRE>
<P CLASS="DESC_TEXT">
clear_ctx:<br>
&nbsp;This routine will set the value of all attributes within the given namespace to<br>
&nbsp;NULL.<br>

<BR>
</P>
<A NAME="Usage"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Usage
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Call this routine when a session is over and the connection is about to be returned to the pool. This prevents the values in the namespace from being inherited by other connections or sessions (I lose track of which is which).<br>

</TD></TR>
</TABLE>
<BR>
<A NAME="Parameters"></A>
<TABLE CLASS="LIST_TABLE"><TR><TD CLASS="LIST_TITLE">
Parameters
</TD></TR></TABLE>
<TABLE CLASS="LIST_TABLE">
<TR><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
</TD><TD VALIGN="TOP" CLASS="LIST_ITEM" WIDTH=1%>
i_ctx_nm&nbsp;&nbsp;
</TD><TD CLASS="DESC_TEXT" WIDTH=95%>
Name of the application context. Defaults to framework's context.<br>

</TD></TR>
</TABLE>
<BR>
<P>&nbsp;</P>
<P>&nbsp;</P>
</BODY>
</HTML>
